#!/usr/bin/env python3
#-*- coding:utf-8 -*-
"""
xortool
  A tool to do some xor analysis:
  - guess the key length (based on count of equal chars)
  - guess the key (base on knowledge of most frequent char)

Usage:
  xortool [-x] [-m MAX-LEN] [-f] [-t CHARSET] [FILE]
  xortool [-x] [-l LEN] [-c CHAR | -b | -o] [-f] [-t CHARSET] [FILE]
  xortool [-x] [-m MAX-LEN| -l LEN] [-c CHAR | -b | -o] [-f] [-t CHARSET] [FILE]
  xortool [-h | --help]
  xortool --version

Options:
  -x --hex                          input is hex-encoded str
  -l LEN, --key-length=LEN          length of the key
  -m MAX-LEN, --max-keylen=MAX-LEN  maximum key length to probe [default: 65]
  -c CHAR, --char=CHAR              most frequent char (one char or hex code)
  -b --brute-chars                  brute force all possible most frequent chars
  -o --brute-printable              same as -b but will only check printable chars
  -f --filter-output                filter outputs based on the charset
  -t CHARSET --text-charset=CHARSET target text character set [default: printable]
  -h --help                         show this help

Notes:
  Text character set:
    * Pre-defined sets: printable, base32, base64
    * Custom sets:
      - a: lowercase chars
      - A: uppercase chars
      - 1: digits
      - !: special chars
      - *: printable chars

Examples:
  xortool file.bin
  xortool -l 11 -c 20 file.bin
  xortool -x -c ' ' file.hex
  xortool -b -f -l 23 -t base64 message.enc
"""

from collections import Counter
from itertools import product
import math
from operator import itemgetter
import os
import string
import sys

import numpy as np

import xortool
from xortool.args import (
    parse_parameters,
    ArgError,
)
from xortool.charset import CharsetError
from xortool.colors import (
    COLORS,
    C_BEST_KEYLEN,
    C_BEST_PROB,
    C_FATAL,
    C_KEY,
    C_RESET,
    C_WARN,
)
from xortool.routine import (
    die,
    mkdir,
    rmdir,
    MkdirError,
)


DIRNAME = 'xortool_out'  # here plaintexts will be placed
PARAMETERS = dict()
BRANCH_FACTOR = 1.1
BRANCH_MAX = 1024*1024

class AnalysisError(Exception):
    pass


def main():
    try:
        PARAMETERS.update(parse_parameters(__doc__, xortool.__version__))
        ciphertext = get_ciphertext()
        if not PARAMETERS["known_key_length"]:
            PARAMETERS["known_key_length"] = guess_key_length(ciphertext)

        if PARAMETERS["brute_chars"]:
            try_chars = bytes(range(256))
        elif PARAMETERS["brute_printable"]:
            try_chars = bytes(map(ord, string.printable))
        elif PARAMETERS["most_frequent_char"] is not None:
            try_chars = PARAMETERS["most_frequent_char"]
        else:
            die(C_WARN +
                "Most possible char is needed to guess the key!" +
                C_RESET)

        key_printer = setup_print_keys()
        produce_plaintext, end = setup_produce_plaintexts(ciphertext, 5)
        for char, key in guess_probable_keys_for_chars(ciphertext, try_chars):
            key_printer(key)
            produce_plaintext(key, char)
        key_printer(None)
        end()

    except IOError as err:
        print(C_FATAL + "[ERROR] Can't load file:\n\t", err, C_RESET)
    except AnalysisError as err:
        print(C_FATAL + "[ERROR] Analysis error:\n\t", err, C_RESET)
    except ArgError as err:
        print(C_FATAL + "[ERROR] Bad argument:\n\t", err, C_RESET)
    except CharsetError as err:
        print(C_FATAL + "[ERROR] Bad charset:\n\t", err, C_RESET)
    except MkdirError as err:
        print(C_FATAL + "[ERROR] Can't create directory:\n\t", err, C_RESET)
    except UnicodeDecodeError as err:
        print(C_FATAL + "[ERROR] Input is not hex:\n\t", err, C_RESET)
    else:
        return
    cleanup()


# -----------------------------------------------------------------------------
# LOADING CIPHERTEXT
# -----------------------------------------------------------------------------

def get_ciphertext():
    """Load ciphertext from a file or stdin and hex-decode if needed"""
    dtype = np.uint8
    filename = PARAMETERS["filename"]
    read_as_string = PARAMETERS["input_is_hex"]
    if filename == "-" or read_as_string:
        if filename == "-":
            filename = sys.stdin.fileno()
        if read_as_string:
            ciphertext = b''
            with open(filename, "r") as fd:
                for line in fd:
                    ciphertext += bytes.fromhex(line)
            return np.array(list(ciphertext), dtype=dtype)
        with open(filename, "rb") as fd:
            return np.array(list(fd.read()), dtype=dtype)
    return np.fromfile(filename, dtype=dtype)


# -----------------------------------------------------------------------------
# KEYLENGTH GUESSING SECTION
# -----------------------------------------------------------------------------

def count_max(a):
    return np.max(np.bincount(a))


def guess_key_length(text):
    """
    Try key lengths from 1 to max_key_length and print local maximums

    Set key_length to the most possible if it's not set by user.
    """
    fitnesses = calculate_fitnesses(text)
    if not fitnesses:
        raise AnalysisError("No candidates for key length found! Too small file?")

    print_fitnesses(fitnesses)
    guess_and_print_divisors(fitnesses)
    return max(fitnesses, key=lambda item: item[1])[0]


def calculate_fitnesses(text):
    """Calculate fitnesses for each keylen"""
    prev = 0
    pprev = 0
    fitnesses = []
    for key_length in range(1, PARAMETERS["max_key_length"] + 1):
        fitness = count_equal_char_sum_by_offset(text, key_length)

        # prefer smaller key-length with nearly the same fitness
        fitness /= PARAMETERS["max_key_length"] + key_length ** 1.5

        if pprev < prev and prev > fitness:  # local maximum
            fitnesses += [(key_length - 1, prev)]

        pprev, prev = prev, fitness

    if pprev < prev:
        fitnesses += [(key_length - 1, prev)]

    return fitnesses


def print_fitnesses(fitnesses):
    print("The most probable key lengths:")

    # top sorted by fitness, but print sorted by length
    fitnesses.sort(key=itemgetter(1), reverse=True)
    top10 = fitnesses[:10]
    best_fitness = top10[0][1]
    top10.sort(key=itemgetter(0))

    fitness_sum = sum(f[1] for f in top10)

    fmt = "{C_KEYLEN}{:" + str(len(str(max(i[0] for i in top10)))) + \
            "}{C_RESET}: {C_PROB}{:5.1f}%{C_RESET}"

    best_colors = COLORS.copy()
    best_colors.update({
        'C_KEYLEN': C_BEST_KEYLEN,
        'C_PROB': C_BEST_PROB,
    })

    for key_length, fitness in top10:
        colors = best_colors if fitness == best_fitness else COLORS
        print(fmt.format(key_length, round(100 * fitness * 1.0 / fitness_sum, 1), **colors))


def count_equal_char_sum_by_offset(text, key_length):
    # We are only interested in extra hits so -1
    if key_length >= text.shape[0]:
        return 1 - 1

    extra_length = text.shape[0] % key_length
    full_key_lengths = text if extra_length == 0 else text[0:-extra_length]
    by_key = np.reshape(full_key_lengths, (-1, key_length)).T

    equals_count = 0

    for offset in by_key:
        equals_count += count_max(offset) - 1

    return equals_count


def guess_and_print_divisors(fitnesses):
    """Prints common divisors and returns the most common divisor"""
    divisors_counts = Counter(number
                              for key_length, _ in fitnesses
                              for number in range(3, key_length + 1)
                              if key_length % number == 0)
    max_divisors = list(divisors_counts.most_common(1))[0][1]

    limit = 3
    ret = 2
    for number, divisors_count in divisors_counts.most_common():
        if divisors_count < max_divisors or limit == 0:
            break
        print("Key-length can be {C_DIV}{}*n{C_RESET}".format(number, **COLORS))
        ret = number
        limit -= 1
    return ret

# -----------------------------------------------------------------------------
# KEYS GUESSING SECTION
# -----------------------------------------------------------------------------

def guess_probable_keys_for_chars(text, try_chars):
    """Generate all possible keys for key length and the most possible char"""
    def highest_count_chars(a, remove_zero):
        nonlocal possibility_budget
        y = np.bincount(a)
        if remove_zero:
            y[0] -= 0
        ii = np.nonzero(y)[0]
        c = y[ii]
        has_max = (ii[c == np.max(c)]).astype(text_dtype)
        if len(has_max) > 1 and possibility_budget > 0:
            possibility_budget -= 1
            return np.random.choice(has_max, 2, replace=False)
        return has_max

    def possible_chars(text_by_key, extra_zero_index):
        chars = []
        for i, offset in enumerate(text_by_key):
            remove_zero = bool(i >= extra_zero_index)
            chars.append(highest_count_chars(offset, remove_zero))
        return chars

    key_len = PARAMETERS["known_key_length"]
    text_len = text.shape[0]
    text_dtype = text.dtype

    extra_zero_index = text_len % key_len
    extra_elements = (key_len - extra_zero_index) % key_len
    if extra_elements > 0:
        full_text = np.zeros(text_len + extra_elements, dtype=text_dtype)
        full_text[0:text_len] = text
    else:
        full_text = text
    text_by_key = np.reshape(full_text, (-1, key_len)).T

    possibilities = text_by_key.shape[0] * len(try_chars)
    possibility_budget = min(int(possibilities * BRANCH_FACTOR), BRANCH_MAX)
    possibility_budget = max(possibility_budget - possibilities, 0)
    possibility_budget = int(possibility_budget / len(try_chars))

    for key_parts in product(*possible_chars(text_by_key, extra_zero_index)):
        key_arr = np.array(key_parts, dtype=text_dtype)
        for char in try_chars:
            yield char, bytes(key_arr ^ char)


def setup_print_keys():
    printed_count = 0
    max_count = 5
    def key_printer(key):
        nonlocal printed_count, max_count
        if printed_count == max_count:
            return
        if key is None:
            if printed_count == 0:
                print("No keys guessed!")
            return
        if printed_count == 0:
            print("Got {C_COUNT}possible{C_RESET} key(s):".format(
                **COLORS))
        print(C_KEY + repr(key) + C_RESET)
        printed_count += 1
        if printed_count == max_count:
            print("...")
    return key_printer


# -----------------------------------------------------------------------------
# RETURNS PERCENTAGE OF VALID TEXT CHARS
# -----------------------------------------------------------------------------

def percentage_valid(text):
    counts = np.zeros(256, dtype=int)
    uniq = np.bincount(text)
    counts[0:uniq.shape[0]] = uniq
    return np.sum(counts[PARAMETERS["text_charset"]]) / text.shape[0]


# -----------------------------------------------------------------------------
# PRODUCE OUTPUT
# -----------------------------------------------------------------------------

def dexor(text, key):
    n_key = np.array(list(key), dtype=np.uint8)
    key_repeats = math.ceil(text.shape[0] / n_key.shape[0])
    key_xor = np.tile(n_key, key_repeats)[0:text.shape[0]]
    return text ^ key_xor


def setup_produce_plaintexts(ciphertext, max_keylen):
    """
    Produce plaintext variant for each possible key

    Creates csv files with keys, percentage of valid
    characters and used most frequent character.
    """
    cleanup()
    mkdir(DIRNAME)

    # this is split up in two files since the
    # key can contain all kinds of characters

    fn_key_mapping = "filename-key.csv"
    fn_perc_mapping = "filename-char_used-perc_valid.csv"

    key_index_fmt = "{:0" + str(max_keylen) + "}.out"

    threshold_valid = 95
    count_valid = 0

    key_mapping = open(os.path.join(DIRNAME, fn_key_mapping), "w", buffering=1)
    perc_mapping = open(os.path.join(DIRNAME, fn_perc_mapping), "w", buffering=1)

    key_mapping.write("file_name;key_repr\n")
    perc_mapping.write("file_name;char_used;perc_valid\n")

    index = 0

    def produce_plaintext(key, char):
        nonlocal key_mapping, perc_mapping
        nonlocal key_index_fmt, index
        nonlocal threshold_valid, count_valid
        file_name = os.path.join(DIRNAME, key_index_fmt.format(index))
        index += 1

        dexored = dexor(ciphertext, key)

        perc = percentage_valid(dexored) * 100
        if perc > threshold_valid:
            count_valid += 1

        key_mapping.write("{};{}\n".format(file_name, repr(key)))
        perc_mapping.write("{};{};{}\n".format(
            file_name, repr(chr(char)), int(perc)))

        if not PARAMETERS["filter_output"] or perc > threshold_valid:
            dexored.tofile(file_name)

    def end():
        nonlocal fn_key_mapping, fn_perc_mapping
        nonlocal key_mapping, perc_mapping
        nonlocal threshold_valid, count_valid
        key_mapping.close()
        perc_mapping.close()
        print("Found {C_COUNT}{}{C_RESET} plaintexts".format(count_valid, **COLORS))
        if PARAMETERS["filter_output"]:
            print("With {C_COUNT}{}%+{C_RESET} valid characters".format(
                int(threshold_valid), **COLORS))
        print("See files {} {}".format(fn_key_mapping, fn_perc_mapping))

    return produce_plaintext, end


def cleanup():
    if os.path.exists(DIRNAME):
        rmdir(DIRNAME)


if __name__ == "__main__":
    main()
